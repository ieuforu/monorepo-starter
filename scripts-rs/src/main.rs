use std::fs;
use std::io::Result;

/// Converts snake_case strings (e.g., "user_profile") to PascalCase (e.g., "UserProfile").
fn snake_to_pascal(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut c = word.chars();
            match c.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
            }
        })
        .collect()
}

// --- Task 1: Process Database Schema ---
fn process_db() -> Result<()> {
    let schema_dir = "packages/db/src/schema";
    let output_file = "packages/db/src/schema/index.ts";
    
    let mut entries = Vec::new();
    for entry in fs::read_dir(schema_dir)? {
        let entry = entry?;
        let name = entry.file_name().into_string().unwrap();
        if name.ends_with(".ts") && name != "index.ts" {
            entries.push(name.replace(".ts", ""));
        }
    }

    let mut content = String::from("// ⚡️ AUTO-GENERATED BY RUST TOOL - DO NOT EDIT\nimport type { z } from 'zod';\n");

    // 1. Internal Imports for aggregated schema object
    for name in &entries {
        content.push_str(&format!("import * as {}Table from './{}';\n", name, name));
    }

    // 2. Aggregated Schema for Drizzle
    content.push_str("\nexport const schema = {\n");
    for name in &entries {
        content.push_str(&format!("  ...{}Table,\n", name));
    }
    content.push_str("};\n\n");

    // 3. Structured Named Exports (Separating Value and Type spaces)
    for name in &entries {
        let pascal = snake_to_pascal(name);
        let table_var = format!("{}s", name); // Assumes table variable is plural (e.g., users)

        content.push_str(&format!("// --- Entity: {} ---\n", pascal));
        
        // Exporting Values (Tables, Zod Schemas)
        content.push_str(&format!(
            "export {{ {}, insert{}Schema, select{}Schema }} from './{}';\n", 
            table_var, pascal, pascal, name
        ));

        // Exporting Types
        content.push_str(&format!(
            "export type {{ {} }} from './{}';\n", 
            pascal, name
        ));
        content.push_str(&format!(
            "export type New{} = z.infer<typeof {}Table.insert{}Schema>;\n\n",
            pascal, name, pascal
        ));
    }

    fs::write(output_file, content)?;
    println!("\x1b[32m  └─> [SUCCESS] Database schema index generated with named exports.\x1b[0m");
    Ok(())
}

// --- Task 2: Process API Root Router ---
fn process_api() -> Result<()> {
    let router_dir = "packages/api/src/router";
    let output_file = "packages/api/src/root.ts";

    let mut entries = Vec::new();
    for entry in fs::read_dir(router_dir)? {
        let entry = entry?;
        let name = entry.file_name().into_string().unwrap();
        if name.ends_with(".ts") {
            entries.push(name.replace(".ts", ""));
        }
    }

    let mut content = String::from("// ⚡️ AUTO-GENERATED BY RUST TOOL - DO NOT EDIT\nimport { createTRPCRouter } from './trpc';\n");

    for name in &entries {
        content.push_str(&format!("import {{ {}Router }} from './router/{}';\n", name, name));
    }

    content.push_str("\nexport const appRouter = createTRPCRouter({\n");
    for name in &entries {
        content.push_str(&format!("  {}: {}Router,\n", name, name));
    }
    content.push_str("});\n\nexport type AppRouter = typeof appRouter;\n");

    fs::write(output_file, content)?;
    println!("\x1b[32m  └─> [SUCCESS] API Root router synchronized.\x1b[0m");
    Ok(())
}

fn main() {
    // Colorful Rust CLI Output
    // \x1b[48;5;208m is Orange/Rust-like background
    // \x1b[30m is Black text
    println!("\n\x1b[48;5;208m\x1b[30m\x1b[1m CRAB_GEN \x1b[0m \x1b[1mRunning monorepo toolchain...\x1b[0m");

    if let Err(e) = process_db() { 
        eprintln!("\x1b[31m❌ DB Task failed: {}\x1b[0m", e); 
    }
    
    if let Err(e) = process_api() { 
        eprintln!("\x1b[31m❌ API Task failed: {}\x1b[0m", e); 
    }
    
    println!(""); // Final newline
}